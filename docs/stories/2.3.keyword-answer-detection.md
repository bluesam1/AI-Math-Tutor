# Story 2.3: Keyword-Based Answer Detection Guardrail

## Status

Pending

## Story

**As a** student,
**I want** the system to never give me direct answers,
**so that** I can learn through guided discovery rather than answer-getting.

## Acceptance Criteria

1: A backend service module is created for keyword-based answer detection (e.g., `answerDetectionService.ts`) in TypeScript that scans LLM responses for common answer patterns.

2: The keyword-based detection identifies patterns such as:

- "the answer is", "the solution is", "equals", "is equal to"
- Numeric results at the end of responses (e.g., "42", "x = 5")
- Direct answer phrases (e.g., "so the answer would be", "therefore the answer is")

3: The detection logic uses regex or pattern matching to identify these patterns in LLM responses.

4: When a direct answer pattern is detected, the service flags the response for blocking or rewriting.

5: The service returns a detection result indicating whether the response contains direct answers, along with the detected patterns.

6: The detection is applied to all LLM-generated responses before they are returned to the frontend.

7: The service includes unit tests validating detection of common answer patterns across different problem types.

8: The detection logic is configurable, allowing for easy addition of new patterns as edge cases are discovered.

## Tasks / Subtasks

- [ ] Task 1: Create Answer Detection Service Module (AC: 1)
  - [ ] Create `functions/src/services/answerDetectionService.ts`
  - [ ] Define TypeScript interfaces for detection results
  - [ ] Create service structure with detection functions
  - [ ] Export detection functions

- [ ] Task 2: Define Answer Pattern Library (AC: 2, 8)
  - [ ] Create pattern configuration file or structure
  - [ ] Define phrase patterns: "the answer is", "the solution is", "equals", "is equal to"
  - [ ] Define numeric result patterns (e.g., "42", "x = 5")
  - [ ] Define direct answer phrases (e.g., "so the answer would be", "therefore the answer is")
  - [ ] Make patterns configurable (easy to add new patterns)
  - [ ] Document pattern format and structure

- [ ] Task 3: Implement Phrase Pattern Matching (AC: 2, 3)
  - [ ] Create regex patterns for answer phrases
  - [ ] Implement case-insensitive matching
  - [ ] Handle variations (e.g., "The answer is", "the answer's", "the answer: is")
  - [ ] Test pattern matching with various phrasings

- [ ] Task 4: Implement Numeric Result Detection (AC: 2, 3)
  - [ ] Detect numeric results at end of responses (e.g., "42", "x = 5")
  - [ ] Create regex for numeric patterns
  - [ ] Handle equations (e.g., "x = 5", "y = 10")
  - [ ] Handle standalone numbers that might be answers
  - [ ] Avoid false positives (numbers in examples, not final answers)

- [ ] Task 5: Implement Direct Answer Phrase Detection (AC: 2, 3)
  - [ ] Create regex patterns for direct answer phrases
  - [ ] Handle variations: "so the answer would be", "therefore the answer is", etc.
  - [ ] Implement phrase matching logic
  - [ ] Test with various phrasings

- [ ] Task 6: Create Detection Function (AC: 1, 4, 5)
  - [ ] Implement `detectAnswer()` function
  - [ ] Accept LLM response text as input
  - [ ] Run all detection patterns against response
  - [ ] Collect all detected patterns
  - [ ] Return detection result with boolean flag and detected patterns

- [ ] Task 7: Return Detection Results (AC: 5)
  - [ ] Define detection result interface:
    - `containsAnswer: boolean`
    - `detectedPatterns: string[]`
    - `confidence: number` (optional)
  - [ ] Return structured detection result
  - [ ] Include all detected patterns in result

- [ ] Task 8: Make Patterns Configurable (AC: 8)
  - [ ] Create configuration file or structure for patterns
  - [ ] Allow adding new patterns without code changes
  - [ ] Support pattern enable/disable flags
  - [ ] Document pattern configuration format
  - [ ] Create pattern management utilities

- [ ] Task 9: Handle Edge Cases (AC: 1-8)
  - [ ] Handle empty responses
  - [ ] Handle very short responses
  - [ ] Handle responses with math expressions that aren't answers
  - [ ] Avoid false positives (e.g., "What is 2 + 2?" should not trigger)
  - [ ] Handle edge cases gracefully

- [ ] Task 10: Add Unit Tests (AC: 7)
  - [ ] Create test file `functions/src/services/__tests__/answerDetectionService.test.ts`
  - [ ] Test phrase pattern detection
  - [ ] Test numeric result detection
  - [ ] Test direct answer phrase detection
  - [ ] Test across different problem types (arithmetic, algebra, geometry, word problems, multi-step)
  - [ ] Test edge cases and false positives
  - [ ] Test with various LLM response formats

- [ ] Task 11: Test with Real Examples (AC: 7)
  - [ ] Collect sample LLM responses (some with answers, some without)
  - [ ] Test detection on real examples
  - [ ] Verify detection accuracy
  - [ ] Refine patterns based on test results
  - [ ] Document test cases and results

- [ ] Task 12: Review Existing Code (AC: 1)
  - [ ] Check if `apps/web/src/testUtils/answerDetection.ts` exists
  - [ ] Review existing implementation (if any)
  - [ ] Decide if code should be moved to backend or refactored
  - [ ] Refactor or create new implementation as needed

## Dependencies

- None (can work in parallel with Story 2.1)

## Required By

- Story 2.5: Answer Blocking & Response Rewriting (will use this detection service)

## Notes

- This is a first-tier guardrail (fast, keyword-based)
- Will be combined with LLM-based detection (Story 2.4) for two-tier protection
- Patterns should be regularly updated as edge cases are discovered
- Consider false positive rate vs. false negative rate (better to flag borderline cases)
- Existing `apps/web/src/testUtils/answerDetection.ts` may need to be moved/refactored to backend

